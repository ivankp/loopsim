#ifndef __LOOPSIM_HH__
#define __LOOPSIM_HH__

//-------------------------------------------------------BEGINHEADER--
// This file is part of LoopSim (arXiv:1006.2144).
//
// Copyright 2009-2011 Mathieu Rubin, Gavin P. Salam and Sebastian Sapeta
//
// This software is provided as a snapshot of the ongoing LoopSim
// research project. As such, you may not redistribute it without the
// authors' permission.
//
// If you use LoopSim as part of your scientific work, you should
// discuss and agree with the LoopSim authors how best to acknowledge
// LoopSim in your work (e.g. whether through a reference, or through
// joint authorship with the LoopSim authors).
//
// To help guide LoopSim's proper use in its current early stage of
// development, a condition of use of LoopSim is that any results that
// you obtain with it must be shown to the LoopSim authors before
// they are made public.
//
// $Id: LoopSim.hh 802 2011-10-07 18:56:01Z salam $
//-------------------------------------------------------ENDHEADER----

#include <vector>
#include "TreeLevel.hh"

namespace loopsim {

//----------------------------------------------------------------------
/// the main class for the LoopSim procedure. An instance of this
/// class is to be constructed for each event from the
/// LO/NLO/etc. generator and the instance of the class will then
/// provide access to all the corresponding "looped" events with their
/// weights.
class LoopSim {
public:

  /// Constructor for the LoopSim class
  ///
  /// \param order the perturbative order of the current event
  ///               0 (LO), 1 (NLO), 2 (NNLO),...
  /// \param iloops  number of loops that are present in the current event
  /// \param ev the current Event given by the generator
  /// \param R radius of the jet algorithm to be used by the TreeLevel class.
  /// \param nborn number of born particles we want
  /// \param spread_virtuals indicates whether looped particles' momenta should
  ///               be spread out over all of the parent's other children
  ///               (leave this at its default value of "true"!)
  LoopSim(int order, int iloops, const Event & ev,
	  double R = 1.0, int nborn = 2, bool spread_virtuals = true);

  /// Function to be used in order to analyse all events that were
  /// generated. Usage as follows
  ///
  /// \code
  /// LoopSim ls(...);
  /// while (ls.there_is_a_next_event()) {
  ///   const Event & ev = ls.extract_next_event();
  ///   // analyse this event
  ///   ...
  /// }
  /// \endcode
  const Event & extract_next_event();
  bool there_is_a_next_event();

  void print_all_events(bool cart = true);


private:
  /// init all the indexes useful for the extraction of all the generated events
  void init_indexes();

  /// fill _tree_levels[ilstart]
  void generate_all_tree_levels(int ilstart);
  /// generate TreeLevel objects with all the events given in the vector
  /// [NB: called by generate_all_tree_levels(int)]
  void generate_some_tree_levels(const std::vector<Event> & evt, int ilstart);

  int _nborn; /// same as in TreeLevel class
  int _order; /// = perturbative order of the current event
  /// _tree_levels[i] contains all TreeLevel objects that are generated by
  /// events with i loops more than the event given in the constructor
  std::vector<std::vector<TreeLevel> > _tree_levels;

  int _nloops_gen; /// number of loops to be generated

  /// indexes that allow to know where we are in the extraction process of
  /// all the events that were generated:
  /// _tree_levels[_tl_i][_tl_j].extract_all_events()[_ev_i][_ev_j];
  int _tl_i, _tl_j;
  int _ev_i, _ev_j;
  int _tl_i_max, _tl_j_max, _ev_i_max, _ev_j_max;

  double _R; //< radius of the jet algorithm
  bool _spread_virtuals; //< whether or not spread virtuals across many reals

  bool _done; /// a variable to test that there_is_a_next_event() was called

};

}

#endif //__LOOPSIM_HH__
